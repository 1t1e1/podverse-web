import { GetServerSideProps } from 'next'
import Head from 'next/head'
import { useTranslation } from 'next-i18next'
import { serverSideTranslations } from 'next-i18next/serverSideTranslations'
import OmniAural from 'omniaural'
import type { Episode, MediaRef, Playlist } from 'podverse-shared'
import { useState } from 'react'
import { ClipListItem, ColumnsWrapper, EpisodeListItem, List, PageScrollableContent,
  PlaylistPageHeader } from '~/components'
import { PV } from '~/resources'
import { getServerSideAuthenticatedUserInfo } from '~/services/auth'
import { Page } from '~/lib/utility/page'
import { isEpisode } from '~/lib/utility/typeHelpers'
import { getServerSideUserQueueItems } from '~/services/userQueueItem'
import { addOrRemovePlaylistItemEpisode, addOrRemovePlaylistItemMediaRef, combineAndSortPlaylistItems, getPlaylist, updatePlaylist } from '~/services/playlist'

interface ServerProps extends Page {
  serverPlaylist: Playlist
  serverPlaylistSortedItems: [Episode | MediaRef]
}

const keyPrefix = 'pages_playlist'

export default function Playlist({ serverPlaylist, serverPlaylistSortedItems }: ServerProps) {
  const { t } = useTranslation()
  const [isEditing, setIsEditing] = useState<boolean>(false)
  const [playlist, setPlaylist] = useState<Playlist>(serverPlaylist)
  const [playlistSortedItems, setPlaylistSortedItems] =
    useState<[Episode | MediaRef]>(serverPlaylistSortedItems)
  const [editingPlaylistTitle, setEditingPlaylistTitle] = useState<string>(serverPlaylist.title)
  const [editingPlaylistIsPublic, setEditingPlaylistIsPublic] =
    useState<boolean>(serverPlaylist.isPublic)
  const pageTitle = playlist.title || t('untitledPlaylist')

  const _handleRemoveEpisode = async (episodeId: string) => {
    const response = await addOrRemovePlaylistItemEpisode(playlist.id, episodeId)
    if (response.actionTaken === 'removed') {
      const newPlaylistSortedItems = playlistSortedItems.filter((playlistItem: Episode | MediaRef) =>
        playlistItem.id !== episodeId
      )
      setPlaylistSortedItems(newPlaylistSortedItems as any)
    }
  }

  const _handleRemoveMediaRef = async (mediaRefId: string) => {
    const response = await addOrRemovePlaylistItemMediaRef(playlist.id, mediaRefId)
    if (response.actionTaken === 'removed') {
      const newPlaylistSortedItems = playlistSortedItems.filter((playlistItem: Episode | MediaRef) =>
        playlistItem.id !== mediaRefId
      )
      setPlaylistSortedItems(newPlaylistSortedItems as any)
    }
  }

  /* Render Helpers */

  const generatePlaylistItemElements = (playlistItems: (Episode | MediaRef)[]) => {
    return playlistItems.map((playlistItem, index) => {
      if (isEpisode(playlistItem)) {
        const episode = playlistItem
        return (
          <EpisodeListItem
            episode={episode}
            handleRemove={() => _handleRemoveEpisode(episode.id)}
            key={`${keyPrefix}-episode-${index}`}
            podcast={episode.podcast as any}
            showImage
            showRemoveButton={isEditing} />
        )
      } else {
        const mediaRef = playlistItem
        return (
          <ClipListItem
            episode={mediaRef.episode}
            handleRemove={() => _handleRemoveMediaRef(mediaRef.id)}
            key={`${keyPrefix}-clip-${index}`}
            mediaRef={mediaRef}
            podcast={mediaRef.episode.podcast}
            showImage
            showRemoveButton={isEditing} />
        )
      }
    })
  }

  /* Commenting out since all playlists are by default Only With Link right now */
  // const _handleChangeIsPublic = async (selectedItems: any[]) => {
  //   const selectedItem = selectedItems[0]
  //   const isPublic = selectedItem.key === PV.Playlists.privacyKeys.public
  //   const playlistData = {
  //     id: playlist.id,
  //     title: editingPlaylistTitle || '',
  //     isPublic
  //   }
  //   OmniAural.pageIsLoadingShow()
  //   const newPlaylist = await updatePlaylist(playlistData)
  //   setPlaylist(newPlaylist)
  //   OmniAural.pageIsLoadingHide()
  // }

  const _handleEditCancel = () => {
    setIsEditing(false)
    setEditingPlaylistTitle(playlist.title)
  }

  const _handleEditSave = async () => {
    const playlistData = {
      id: playlist.id,
      title: editingPlaylistTitle || '',
      isPublic: editingPlaylistIsPublic
    }
    OmniAural.pageIsLoadingShow()
    const newPlaylist = await updatePlaylist(playlistData)
    setPlaylist(newPlaylist)
    OmniAural.pageIsLoadingHide()
    setIsEditing(false)
  }

  const _handleEditStart = () => {
    setIsEditing(true)
  }

  return (
    <>
      <Head>
        <title>{pageTitle}</title>
        <meta name="description" content="Generated by create next app" />
        <link rel="icon" href="/favicon.ico" />
      </Head>
      <PlaylistPageHeader
        // handleChangeIsPublic={_handleChangeIsPublic}
        handleEditCancel={_handleEditCancel}
        handleEditSave={_handleEditSave}
        handleEditStart={_handleEditStart}
        handlePlaylistTitleOnChange={setEditingPlaylistTitle}
        isEditing={isEditing}
        playlist={playlist} />
      <PageScrollableContent>
        <ColumnsWrapper
          mainColumnChildren={
            <>
              <List>
                {generatePlaylistItemElements(playlistSortedItems)}
              </List>
            </>
          }
        />
      </PageScrollableContent>
    </>
  )
}

/* Server-Side Logic */

export const getServerSideProps: GetServerSideProps = async (ctx) => {
  const { locale, params, req } = ctx
  const { cookies } = req
  const { playlistId } = params

  const userInfo = await getServerSideAuthenticatedUserInfo(cookies)
  const userQueueItems = await getServerSideUserQueueItems(cookies)

  const playlist = await getPlaylist(playlistId as string)

  const sortedPlaylistItems = combineAndSortPlaylistItems(playlist.episodes,
    playlist.mediaRefs, playlist.itemsOrder) as any

  const serverProps: ServerProps = {
    serverUserInfo: userInfo,
    serverUserQueueItems: userQueueItems,
    ...(await serverSideTranslations(locale, PV.i18n.fileNames.all)),
    serverCookies: cookies,
    serverPlaylist: playlist,
    serverPlaylistSortedItems: sortedPlaylistItems
  }

  return {
    props: serverProps
  }
}
